(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{284:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),s("p",[t._v("目前开发的Qt监控程序需要能够承受在7×24小时连续工作，经过测试程序在24小时运行后，内存达到惊人的的1G左右，因此针对这个问题，对代码进行优化调整。")]),t._v(" "),s("h2",{attrs:{id:"分析原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分析原因"}},[t._v("#")]),t._v(" 分析原因")]),t._v(" "),s("p",[t._v("内存持续增长，很显然存在内存泄漏问题。")]),t._v(" "),s("h3",{attrs:{id:"第三方库引起内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第三方库引起内存泄漏"}},[t._v("#")]),t._v(" 第三方库引起内存泄漏")]),t._v(" "),s("p",[t._v("经过观察，程序每隔30s内会有明显增长。根据这个现象，很快定位在调用第三方计算库后内存会涨，目前来看是第三方库的问题。")]),t._v(" "),s("p",[t._v("经过协调，第三方库提供了内存修复的版本，新版本发布后，内存增长有了缓解，但是依然达不到要求。")]),t._v(" "),s("h3",{attrs:{id:"qt-容器类的内存分配问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#qt-容器类的内存分配问题"}},[t._v("#")]),t._v(" Qt 容器类的内存分配问题")]),t._v(" "),s("p",[t._v("排除第三方库引起的内存泄漏后，很显然我们自身的程序也存在问题，在排除new/delete等低级错误后，我把目光集中到Qt的几个常用容器类上。当初开发使用Qt，为了方便，使用了很多"),s("code",[t._v("QList")]),t._v("、"),s("code",[t._v("QStringList")]),t._v("、"),s("code",[t._v("QVector")]),t._v("等常用容器类。使用断点调试，我一步一步定位，发现在几个清理过程中，内存并没有如想象一般减少。")]),t._v(" "),s("p",[s("code",[t._v("QList")]),t._v("内存由Qt自身控制，会在程序结束后统一回收，很显然对长时间运行的程序，无法及时释放导致程序内存越来越大，我们需要手动控制内存。")]),t._v(" "),s("div",{staticClass:"language-CPP extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("QList")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reserve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" alloc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nReserve space "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" alloc elements"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("If alloc is smaller than the current size of \nthe list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nothing will happen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Use "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" function to avoid repetetive \nreallocation of QList"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("'")]),t._v("s internal data "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" you can predict how many elements \nwill be appended"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" Note that the reservation applies only to the internal \npointer array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("This function was introduced in Qt "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("使用"),s("code",[t._v("reserve()")]),t._v("预分配最大可用空间，在"),s("code",[t._v("Qlist")]),t._v("超过预分配的内存空间，在执行"),s("code",[t._v("clear()")]),t._v("时会马上释放多余分配的空间，从而实现对内存的控制。")]),t._v(" "),s("h3",{attrs:{id:"巧用容器类构造函数实现内存的释放"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#巧用容器类构造函数实现内存的释放"}},[t._v("#")]),t._v(" 巧用容器类构造函数实现内存的释放")]),t._v(" "),s("div",{staticClass:"language-CPP extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化容器类")]),t._v("\nQList"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nlist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pust")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token generic-function"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("QList")]),s("span",{pre:!0,attrs:{class:"token generic class-name"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("这里使用swap函数，清空list分配的内存，实现资源的释放")]),t._v(" "),s("h2",{attrs:{id:"结束"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结束"}},[t._v("#")]),t._v(" 结束")]),t._v(" "),s("p",[t._v("目前先总结到这儿，期待后续修改的效果，在此做个记录。")])])}),[],!1,null,null,null);s.default=e.exports}}]);