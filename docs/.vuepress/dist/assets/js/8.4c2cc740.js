(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{211:function(t,a,e){"use strict";e.r(a);var s=e(2),n=Object(s.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("目前开发的Qt监控程序需要能够承受在7×24小时连续工作，经过测试程序在24小时运行后，内存达到惊人的的1G左右，因此针对这个问题，对代码进行优化调整。")]),t._v(" "),e("h2",{attrs:{id:"分析原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析原因","aria-hidden":"true"}},[t._v("#")]),t._v(" 分析原因")]),t._v(" "),e("p",[t._v("内存持续增长，很显然存在内存泄漏问题。")]),t._v(" "),e("h3",{attrs:{id:"第三方库引起内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三方库引起内存泄漏","aria-hidden":"true"}},[t._v("#")]),t._v(" 第三方库引起内存泄漏")]),t._v(" "),e("p",[t._v("经过观察，程序每隔30s内会有明显增长。根据这个现象，很快定位在调用第三方计算库后内存会涨，目前来看是第三方库的问题。")]),t._v(" "),e("p",[t._v("经过协调，第三方库提供了内存修复的版本，新版本发布后，内存增长有了缓解，但是依然达不到要求。")]),t._v(" "),e("h3",{attrs:{id:"qt-容器类的内存分配问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#qt-容器类的内存分配问题","aria-hidden":"true"}},[t._v("#")]),t._v(" Qt 容器类的内存分配问题")]),t._v(" "),e("p",[t._v("排除第三方库引起的内存泄漏后，很显然我们自身的程序也存在问题，在排除new/delete等低级错误后，我把目光集中到Qt的几个常用容器类上。当初开发使用Qt，为了方便，使用了很多"),e("code",[t._v("QList")]),t._v("、"),e("code",[t._v("QStringList")]),t._v("、"),e("code",[t._v("QVector")]),t._v("等常用容器类。使用断点调试，我一步一步定位，发现在几个清理过程中，内存并没有如想象一般减少。")]),t._v(" "),e("p",[e("code",[t._v("QList")]),t._v("内存由Qt自身控制，会在程序结束后统一回收，很显然对长时间运行的程序，无法及时释放导致程序内存越来越大，我们需要手动控制内存。")]),t._v(" "),e("div",{staticClass:"language-C extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" QList"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("reserve")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" alloc"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nReserve space "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" alloc elements"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("If alloc is smaller than the current size of \nthe list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nothing will happen"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Use this function to avoid repetetive \nreallocation of QList's internal data "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" you can predict how many elements \nwill be appended"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" Note that the reservation applies only to the internal \npointer array"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("This function was introduced in Qt "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.7")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),e("p",[t._v("使用"),e("code",[t._v("reserve()")]),t._v("预分配最大可用空间，在"),e("code",[t._v("Qlist")]),t._v("超过预分配的内存空间，在执行"),e("code",[t._v("clear()")]),t._v("时会马上释放多余分配的空间，从而实现对内存的控制。")]),t._v(" "),e("h2",{attrs:{id:"结束"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结束","aria-hidden":"true"}},[t._v("#")]),t._v(" 结束")]),t._v(" "),e("p",[t._v("目前先总结到这儿，期待后续修改的效果，在此做个记录。")])])},[],!1,null,null,null);a.default=n.exports}}]);